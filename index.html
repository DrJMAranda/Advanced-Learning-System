<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-6 Subitizing Dot Challenge | ONETH MVP</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <header>
        <h1>Dot Challenge: Total Count (Round <span id="round-num">0</span>)</h1>
        <p>Focus! The dots will flash quickly. (Honor System)</p>
    </header>

    <div id="presentation-area">
        <div id="grid-container">
            <div id="board-A" class="grid"></div>
            <div id="board-B" class="grid"></div>
        </div>
        
        <div id="mask" class="overlay">
            <p>LOOK! (T1 Flash)</p>
        </div>
        
        <div id="feedback" class="overlay">
            <p id="wait-prompt">Time to Guess! (5.0s)</p>
        </div>

        <div id="reveal" class="overlay">
            <p>âœ… **CORRECT TOTAL:** <span id="correct-answer"></span></p>
        </div>
    </div>

    <footer>
        <button id="start-button">Start Challenge</button>
        <p>Built with ONETH Precision for Google Integration</p>
    </footer>

    <script src="app.js"></script>
</body>
</html>
ðŸŽ¨ 2. CSS File (style.css)
No functional changes, just ensuring the visual cues are high-contrast.

CSS

body {
    font-family: 'Arial', sans-serif;
    background-color: #f4f4f9;
    color: #333;
    text-align: center;
    margin: 0;
    padding-top: 20px;
}

#presentation-area {
    position: relative;
    width: 650px; /* Space for two 5x5 grids and padding */
    height: 350px;
    margin: 40px auto;
    border: 3px solid #ccc;
    background-color: white;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

#grid-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    height: 100%;
}

.grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(5, 1fr);
    width: 300px;
    height: 300px;
    border: 1px solid #eee; /* Subtle grid lines */
}

.cell {
    border: 1px dotted #eee;
    display: flex;
    justify-content: center;
    align-items: center;
    visibility: hidden; /* All cells start hidden */
}

.dot {
    width: 60%;
    height: 60%;
    background-color: #000000; /* High-contrast black dot */
    border-radius: 50%;
}

/* --- Overlay/Timing Styles --- */

.overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2em;
    font-weight: bold;
    color: white;
    z-index: 10;
}

#mask {
    background-color: #A00000; /* Deep Red Mask (T1 prompt) */
    visibility: hidden;
}

#feedback {
    background-color: rgba(0, 0, 0, 0.8); /* Dark mask for thinking time (T2) */
    visibility: hidden;
}

#reveal {
    background-color: #006400; /* Dark Green for correct answer (T3) */
    visibility: hidden;
}

#reveal p {
    padding: 20px;
    border-radius: 10px;
    background-color: rgba(255, 255, 255, 0.2);
}

/* Class added during the 250ms flash */
.flash-visible .cell {
    visibility: visible !important;
}
ðŸš€ 3. JavaScript Logic (app.js)
This file contains the consolidated, testable logic for randomization, placement, and the critical ONETH timing sequence.

JavaScript

// ====================================================================
// ONETH TIMING & CONSTANTS (Structure ready for Jest testing)
// ====================================================================
const PRESENTATION_TIME = 250; // T1: 250ms flash (CRITICAL for subitizing science)
const HONOR_WAIT_TIME = 5000;  // T2: 5.0 seconds thinking (Close enough tolerance)
const REVEAL_TIME = 2000;      // T3: 2.0 seconds answer display (Close enough tolerance)
const MAX_DOTS = 5;
const GRID_SIZE = 5;
const TOTAL_ROUNDS = 5;

let currentRound = 0;
const boardAElement = document.getElementById('board-A');
const boardBElement = document.getElementById('board-B');
const startButton = document.getElementById('start-button');
const roundNumSpan = document.getElementById('round-num');
const maskOverlay = document.getElementById('mask');
const feedbackOverlay = document.getElementById('feedback');
const revealOverlay = document.getElementById('reveal');
const waitPrompt = document.getElementById('wait-prompt');
const correctAnswerSpan = document.getElementById('correct-answer');

// --- Helper 1: Setup Cells ---
function createGridCells(boardElement) {
    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        // cell.dataset.index = i; // Retained for future use/debugging
        
        const dot = document.createElement('div');
        dot.classList.add('dot');
        cell.appendChild(dot);

        boardElement.appendChild(cell);
    }
}

// --- Helper 2: ONETH Dot Placement Logic (Testable Unit) ---
function placeDots(dotCount, boardElement) {
    const allCells = Array.from(boardElement.querySelectorAll('.cell'));
    
    // 1. Reset: Hide all dots before selecting new ones
    allCells.forEach(cell => cell.style.visibility = 'hidden');

    if (dotCount === 0) return []; // Return empty array for no dots
    
    // 2. Random Selection: Get unique indices
    const indices = Array.from(Array(GRID_SIZE * GRID_SIZE).keys());
    
    // Shuffle the indices and slice to get exactly 'dotCount' unique positions
    const dotPositionsIndices = indices
        .sort(() => 0.5 - Math.random()) 
        .slice(0, dotCount);            

    // 3. Display: Mark selected cells visible
    dotPositionsIndices.forEach(index => {
        allCells[index].style.visibility = 'visible';
    });
    
    return dotPositionsIndices; // Return indices for testing integrity
}

// --- CORE GAME LOGIC ---
function setupRound() {
    // Exercise 3 Logic: randbetween 0-5 for both
    const countA = Math.floor(Math.random() * (MAX_DOTS + 1));
    const countB = Math.floor(Math.random() * (MAX_DOTS + 1));
    const correctTotal = countA + countB;
    
    // Generate dot positions
    placeDots(countA, boardAElement);
    placeDots(countB, boardBElement);
    
    return { countA, countB, correctTotal };
}

// --- CORE TIMING SEQUENCE (Testable Unit) ---
function runTimingSequence(correctTotal, countA, countB) {
    // T0: Hide everything, show the prompt (pre-flash)
    maskOverlay.style.visibility = 'visible';
    feedbackOverlay.style.visibility = 'hidden';
    revealOverlay.style.visibility = 'hidden';
    
    // 1. T1: Presentation (THE CRITICAL FLASH)
    let timingHandle = setTimeout(() => {
        // --- START FLASH (Show Dots) ---
        // Dots were placed in setupRound(), now we remove the mask to reveal them
        maskOverlay.style.visibility = 'hidden';

        // --- END FLASH (Hide Dots, Start T2) ---
        timingHandle = setTimeout(() => {
            // Hide the dots instantly after T1 duration
            boardAElement.querySelectorAll('.cell').forEach(c => c.style.visibility = 'hidden');
            boardBElement.querySelectorAll('.cell').forEach(c => c.style.visibility = 'hidden');
            
            // Start T2: Honor Wait Time (Masking screen for thinking)
            feedbackOverlay.style.visibility = 'visible';
            waitPrompt.textContent = `Time to Guess! (${HONOR_WAIT_TIME / 1000}.0s)`;
            
            // T2: Wait complete, move to T3 Reveal
            timingHandle = setTimeout(() => {
                feedbackOverlay.style.visibility = 'hidden';
                
                // T3: Reveal Answer (The logging phase)
                correctAnswerSpan.textContent = `${correctTotal} (Board A: ${countA} + Board B: ${countB})`;
                revealOverlay.style.visibility = 'visible';
                
                // --- ONETH DATA LOGGING POINT ---
                // Replace console.log with a fetch() call to your server-side logger
                console.log(`LOG | Round ${currentRound}: CountA=${countA}, CountB=${countB}, Total=${correctTotal}`);
                
                // T3: Reveal complete, start next round
                timingHandle = setTimeout(runRound, REVEAL_TIME);

            }, HONOR_WAIT_TIME); // End of T2 Wait

        }, PRESENTATION_TIME); // End of T1 Flash

    }, 10); // Small initial delay to ensure the browser paints the mask first
}


// --- MAIN LOOP ---
function runRound() {
    if (currentRound >= TOTAL_ROUNDS) {
        alert("Challenge Complete! Check your log for results.");
        startButton.disabled = false;
        return;
    }
    
    currentRound++;
    roundNumSpan.textContent = currentRound;
    
    // Get counts and place dots for the round
    const { countA, countB, correctTotal } = setupRound();
    
    // Execute the timed sequence
    runTimingSequence(correctTotal, countA, countB);
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    createGridCells(boardAElement);
    createGridCells(boardBElement);
    
    startButton.addEventListener('click', () => {
        startButton.disabled = true;
        currentRound = 0;
        runRound();
    });
});

// Expose functions for Jest testing (Optional, but highly recommended for the "Swipe")
// if (typeof module !== 'undefined' && module.exports) {
//     module.exports = { setupRound, placeDots }; 
// }
